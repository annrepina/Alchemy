#pragma once
#include <iostream>
#include <string>
#include <vector>
#include <map>

using namespace std;

#define NO_DELIM		-1
#define PIVOT_INDEX		0	// Индекс пивота
#define MIN_SIZE		2	// Минимальныо требуемый размер массива для сортировки
#define NO_POSITION		-1	// Нет такой позиции в контейнере

// Генерирует случайные числа в диапазоне заданном пользователем min - max
int randInRange(const int min, const int max);

// Разделяет строку на подстроки по символу разделителю
vector <string> splitForOneDelim(string str, char delim);

// Находит индексы делиметров и заносит их в вектор
int findDelimetrIndexes(const char delimetr, const size_t length, const string str);

// Попытаться привести к инту
bool tryParseToInt(string value);

template<typename T>
void fillMap(map<int, T>& map, vector <T> vector, int startKey, int border)
{
	// если ассоциативный массив пустой
	if (map.empty())
	{
		// Заполняем ассоциативный массив
		for (int i = 0; i < border; ++i, ++startKey)
		{
			map.emplace(startKey, vector[i]);
		}
	}

}

template<typename T>
void quickSort(T* vec, int size)
{
	// Разделяющий элемент, с которым будет происходить сравнение других элементов - всегда начальный элемент массива
	T pivot = vec[PIVOT_INDEX];

	// Индекс начального левого элемента - начальный индекс массива
	auto left = 0;

	// Индекс начального правого элемента - последний индекс массива
	auto right = size - 1;

	// цикл продолжается, пока не встретится break
	while (true)
	{
		// ищем справа элемент меньше пивота
		// уменьшаем правый индекс до тех пор, пока элементы больше либо равны пивоту и пока правый индекс больше левого
		while (right > left && vec[right] >= pivot)
		{
			--right;
		}

		// ищем слева элемент больше пивота
		// увеличиваем левый индекс до тех пор, пока элементы меньше либо равны пивоту и пока левый элемент меньше правого
		while (left < right && vec[left] <= pivot)
		{
			++left;
		}

		// если индексы сравнялись во время поиска
		if (right == left)
		{
			// меняем местами пивот и элемент, на котором индексы сравнялись, 
			//после этого пивот занял свою позицию и разделил масив на 2 части
			swap(vec[PIVOT_INDEX], vec[right]);

			break;
		}

		// если left и right не пересеклись свопаем соответствующие элементы, 
		// перекидывая элементы меньше пивота - влево, а больше - вправо
		swap(vec[left], vec[right]);
	}

	// если правый индекс больше или равен минимального размера массива, который нужно отсортировать, 
	// значит слева осталось неотсортировано 2 или больше элелементов
	// вызываем функцию на их сортировку
	if (right >= MIN_SIZE)
	{
		// передаем указатель на массив без изменений - начинаем с 0го элемента исходного массива
		// размер массива равен индексу правого элемента
		quickSort(vec, right);
	}

	// если правый индекс меньше размера массива минус 2, значит справа осталось неотсортировано 2 или больше элелементов
	// вызываем функцию на их сортировку
	if (right < size - 2)
	{
		// передаем указатель на массив + right + 1. Т.е. задаем адрес т.н. нулевого элемента передаваемой части массива
		// размер массива равен исходному размеру за вычетом right и 1
		quickSort(vec + right + 1, size - right - 1);
	}
}

template<typename T>
int binarySearch(vector<T> vec,/* const int ARRAY_SIZE,*/ int key)
{
	// Индекс искомого числа (остается -1, если число не найдено в массиве)
	int index = NO_POSITION;

	// индекс начального элемента поиска в промежутке
	int min = 0;

	int size = vec.size();

	// индекс конечного элемента поиска в промежутке
	// указываем максимальный индекс как размер массива, т.е. несмотря на то, что этого индекса нет в самом массиве
	// потому что если указывать max = ARRAY_SIZE - 1, т.е. последний индекс 19, то алгоритм не находит последний элемент. 
	// т.к. 18+19=37, 37/2 = 18, и 19ый элемент никогда не находится.
	int max = size;

	for (int i = 0; i <= size / 2; ++i)
	{
		if (key == vec[(min + max) / 2])
		{
			index = (min + max) / 2;
			break;
		}

		else if (key > vec[(min + max) / 2])
		{
			min = (min + max) / 2;
		}

		else
		{
			max = (min + max) / 2;
		}
	}

	return index;
}
